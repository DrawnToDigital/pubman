/**
 * Client-side MakerWorld API that uses Electron IPC to bypass Cloudflare
 * This routes all requests through Electron's authenticated session
 */

import { z } from 'zod';
import log from 'electron-log/renderer';

// Window.electron types are defined in MakerWorldAuthContext.tsx

// Schemas
export const UserInfoResponseSchema = z.object({
  uid: z.number(),
  name: z.string(),
  handle: z.string(),
  avatar: z.string(),
  backgroundUrl: z.string(),
}).passthrough();

// Schema for draft summary (list response)
export const DraftSummarySchema = z.object({
  id: z.number(),
  designId: z.number(),
  title: z.string(),
  summary: z.string(),
  categoryId: z.number(),
  tags: z.array(z.string()),
  cover: z.string(),
  updateTime: z.string(),
  createTime: z.string(),
  status: z.number(),
  license: z.string().optional(),
}).passthrough();

// Schema for published design from __NEXT_DATA__ (has different field names)
export const PublishedDesignSchema = z.object({
  id: z.number(),
  title: z.string(),
  coverUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
  license: z.string().optional(),
  createTime: z.string().optional(),
  publishTime: z.string().optional(),
  instances: z.array(z.object({
    id: z.number(),
    title: z.string().optional(),
    cover: z.string().optional(),
    summary: z.string().optional(),
  }).passthrough()).optional(),
}).passthrough();

// Schema for design detail response (from /design/{id} API)
export const DesignDetailSchema = z.object({
  id: z.number(),
  title: z.string(),
  summary: z.string().optional(),
  details: z.string().optional(), // HTML description
  categoryId: z.number().optional(),
  tags: z.array(z.string()).optional(),
  license: z.string().optional(),
  cover: z.string().optional(),
  nsfw: z.boolean().optional(),
  instances: z.array(z.object({
    id: z.number(),
    title: z.string().optional(),
    cover: z.string().optional(),
    summary: z.string().optional(),
  }).passthrough()).optional(),
}).passthrough();

// Schema for model download response
export const ModelDownloadSchema = z.object({
  name: z.string(),
  url: z.string(),
});

// Schema for instance 3MF download response
export const Instance3MFDownloadSchema = z.object({
  name: z.string(),
  url: z.string(),
});

export const GetDraftsResponseSchema = z.object({
  hits: z.array(DraftSummarySchema),
  total: z.number(),
});

// Schema for model file in draft details
export const ModelFileSchema = z.object({
  isAutoGenerated: z.boolean(),
  isDir: z.boolean(),
  modelName: z.string(),
  modelSize: z.number(),
  modelType: z.string(),
  modelUpdateTime: z.string().default(''),
  modelUrl: z.string(),
  thumbnailName: z.string().default(''),
  thumbnailSize: z.number().default(0),
  thumbnailUrl: z.string().default(''),
  unikey: z.string(),
}).passthrough();

// Schema for design picture
export const DesignPictureSchema = z.object({
  name: z.string(),
  url: z.string(),
}).passthrough();

export const DraftDetailResponseSchema = z.object({
  id: z.number(),
  designId: z.number(),
  title: z.string(),
  summary: z.string(),
  categoryId: z.number(),
  tags: z.array(z.string()),
  cover: z.string(),
  updateTime: z.string(),
  createTime: z.string(),
  status: z.number(),
  license: z.string(),
  nsfw: z.boolean(),
  modelFiles: z.array(ModelFileSchema).optional(),
  designPictures: z.array(DesignPictureSchema).optional(),
}).passthrough();

export class MakerWorldClientAPIError extends Error {
  url?: string;
  method?: string;
  requestBody?: string;
  responseStatus?: number;
  responseStatusText?: string;
  responseBody?: string;

  constructor(params: {
    message: string;
    url?: string;
    method?: string;
    requestBody?: string;
    responseStatus?: number;
    responseStatusText?: string;
    responseBody?: string;
  }) {
    super(params.message);
    this.name = 'MakerWorldClientAPIError';
    Object.assign(this, params);
  }
}

// MakerWorld draft status codes
export const MAKERWORLD_STATUS = {
  0: 'new',
  1: 'draft',
  3: 'published',
  6: 'submitted',
  10: 'pending_review',
} as const;

export function getMakerWorldStatusName(status: number): string {
  return MAKERWORLD_STATUS[status as keyof typeof MAKERWORLD_STATUS] || `unknown(${status})`;
}

export class MakerWorldClientAPI {
  private bblApiUrl = 'https://api.bambulab.com';
  private mwApiUrl = 'https://makerworld.com/api';
  private s3ConfigCache: {
    config: {
      region: string;
      endpoint: string;
      accessKeyId: string;
      accessKeySecret: string;
      securityToken: string;
      bucketName: string;
      cdnUrl: string;
    } | null;
    expiresAt: number;
  } = { config: null, expiresAt: 0 };

  // Note: Authentication is handled by session cookies in Electron's persist:makerworld partition
  // No access token is needed as session.fetch() automatically includes the auth cookies
  constructor() {}

  private validateId(id: string | number, paramName: string): void {
    if (id === '' || id === null || id === undefined) {
      throw new Error(`Invalid ${paramName}: value is empty or undefined`);
    }
    if (typeof id === 'number' && (isNaN(id) || id <= 0)) {
      throw new Error(`Invalid ${paramName}: ${id} is not a positive number`);
    }
  }

  private async fetch(url: string, options: { method?: string; body?: string } = {}): Promise<unknown> {
    if (!window.electron?.makerworld?.fetch) {
      throw new Error('MakerWorld IPC not available - are you running in Electron?');
    }

    const method = options.method || 'GET';

    // session.fetch() automatically includes cookies from the persist:makerworld partition
    // The 'token' cookie handles authentication for all MakerWorld/BambuLab API requests
    // No Authorization header needed - session cookies are used instead
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    };

    // Log request details (full body for debugging)
    log.info(`[MakerWorld API] >>> ${method} ${url}`);
    if (options.body) {
      log.info(`[MakerWorld API] >>> Request body:`, options.body);
    }

    const startTime = Date.now();
    const response = await window.electron.makerworld.fetch(url, {
      method,
      headers,
      body: options.body,
    });
    const elapsed = Date.now() - startTime;

    // Log response details (full body for debugging)
    log.info(`[MakerWorld API] <<< ${response.status} ${response.statusText} (${elapsed}ms)`);
    if (response.body) {
      log.info(`[MakerWorld API] <<< Response body:`, response.body);
    } else {
      log.info(`[MakerWorld API] <<< Response body: (empty)`);
    }

    if (!response.ok) {
      const error = new MakerWorldClientAPIError({
        message: `MakerWorld API error: ${response.status} ${response.statusText}`,
        url,
        method,
        requestBody: options.body,
        responseStatus: response.status,
        responseStatusText: response.statusText,
        responseBody: response.body,
      });
      log.error(`[MakerWorld API] Request failed:`, {
        url,
        method,
        status: response.status,
        statusText: response.statusText,
      });
      throw error;
    }

    try {
      return response.body ? JSON.parse(response.body) : null;
    } catch (parseError) {
      log.error(`[MakerWorld API] Failed to parse response as JSON:`, parseError);
      throw new MakerWorldClientAPIError({
        message: 'Failed to parse response',
        url,
        method,
        responseStatus: response.status,
        responseBody: response.body,
      });
    }
  }

  async getUserInfo() {
    const url = `${this.bblApiUrl}/v1/design-user-service/my/preference`;
    const res = await this.fetch(url);
    const parsed = UserInfoResponseSchema.safeParse(res);
    if (!parsed.success) {
      throw new MakerWorldClientAPIError({
        message: 'Invalid user info response',
        url,
        responseBody: JSON.stringify(res),
      });
    }
    return parsed.data;
  }

  async getS3Config() {
    // Check cache first (with 5 minute buffer before expiration)
    const now = Date.now();
    if (this.s3ConfigCache.config && this.s3ConfigCache.expiresAt > now + 5 * 60 * 1000) {
      log.info(`[MakerWorld API] Using cached S3 config (expires in ${Math.round((this.s3ConfigCache.expiresAt - now) / 1000)}s)`);
      return this.s3ConfigCache.config;
    }

    const url = `${this.mwApiUrl}/v1/user-service/my/s3config?useType=1`;
    const config = await this.fetch(url) as {
      region: string;
      endpoint: string;
      accessKeyId: string;
      accessKeySecret: string;
      securityToken: string;
      bucketName: string;
      cdnUrl: string;
      expiration?: string;
    };

    // Cache the config with expiration
    if (config && config.expiration) {
      this.s3ConfigCache = {
        config,
        expiresAt: new Date(config.expiration).getTime(),
      };
      log.info(`[MakerWorld API] Cached S3 config until ${config.expiration}`);
    }

    return config;
  }

  async createDraft(draftData: Record<string, unknown>) {
    const url = `${this.mwApiUrl}/v1/design-service/my/draft`;
    return await this.fetch(url, {
      method: 'POST',
      body: JSON.stringify(draftData),
    });
  }

  async updateDraft(draftId: string | number, draftData: Record<string, unknown>) {
    this.validateId(draftId, 'draftId');
    const url = `${this.mwApiUrl}/v1/design-service/my/draft/${draftId}`;
    await this.fetch(url, {
      method: 'PUT',
      body: JSON.stringify(draftData),
    });
    return null;
  }

  async getDraftById(draftId: string | number) {
    this.validateId(draftId, 'draftId');
    const url = `${this.mwApiUrl}/v1/design-service/my/draft/${draftId}`;
    const res = await this.fetch(url);
    const parsed = DraftDetailResponseSchema.safeParse(res);
    if (!parsed.success) {
      log.warn('Draft validation issues:', parsed.error.issues);
    }
    return res as z.infer<typeof DraftDetailResponseSchema>;
  }

  async publishDraft(draftId: string | number): Promise<{ designId?: number }> {
    this.validateId(draftId, 'draftId');
    const url = `${this.mwApiUrl}/v1/design-service/my/draft/${draftId}/submit`;
    const res = await this.fetch(url, { method: 'POST' });
    return (res || {}) as { designId?: number };
  }

  async uploadFileToS3(
    fileName: string,
    fileData: ArrayBuffer,
    userId: number,
    s3Config: {
      region: string;
      endpoint: string;
      accessKeyId: string;
      accessKeySecret: string;
      securityToken: string;
      bucketName: string;
      cdnUrl: string;
    }
  ): Promise<{ url: string }> {
    // Generate the S3 key (matching the original format)
    const today = new Date().toISOString().slice(0, 10);
    const randomHex = Array.from(crypto.getRandomValues(new Uint8Array(8)))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
    const fileExt = fileName.includes('.') ? fileName.split('.').pop() : 'bin';
    const key = `makerworld/user/${userId}/draft/${today}_${randomHex}.${fileExt}`;

    log.info(`[MakerWorld S3] >>> PUT s3://${s3Config.bucketName}/${key}`);
    log.info(`[MakerWorld S3] >>> File: ${fileName}, Size: ${fileData.byteLength} bytes`);

    const { S3Client, PutObjectCommand } = await import('@aws-sdk/client-s3');

    const client = new S3Client({
      region: s3Config.region,
      endpoint: `https://${s3Config.endpoint}`,
      credentials: {
        accessKeyId: s3Config.accessKeyId,
        secretAccessKey: s3Config.accessKeySecret,
        sessionToken: s3Config.securityToken,
      },
    });

    // Sanitize filename for Content-Disposition header to prevent header injection
    // Remove all control characters (0x00-0x1F, 0x7F) plus quotes and backslashes
    const sanitizedFileName = fileName.replace(/[\x00-\x1F\x7F"\\]/g, '_');

    const command = new PutObjectCommand({
      Bucket: s3Config.bucketName,
      Key: key,
      Body: new Uint8Array(fileData),
      ContentDisposition: `attachment; filename="${sanitizedFileName}"`,
      ContentType: 'application/octet-stream',
    });

    try {
      await client.send(command);
      const resultUrl = `${s3Config.cdnUrl}/${key}`;
      log.info(`[MakerWorld S3] <<< Upload successful: ${resultUrl}`);
      return { url: resultUrl };
    } catch (error) {
      log.error(`[MakerWorld S3] <<< Upload failed:`, error);
      throw error;
    }
  }

  async uploadFile(fileName: string, fileData: ArrayBuffer, userId: number): Promise<{ url: string }> {
    const s3Config = await this.getS3Config() as {
      region: string;
      endpoint: string;
      accessKeyId: string;
      accessKeySecret: string;
      securityToken: string;
      bucketName: string;
      cdnUrl: string;
    };

    if (!s3Config || !s3Config.bucketName) {
      throw new MakerWorldClientAPIError({
        message: 'Failed to get S3 configuration',
        url: `${this.mwApiUrl}/v1/user-service/my/s3config?useType=1`,
      });
    }

    return await this.uploadFileToS3(fileName, fileData, userId, s3Config);
  }

  /**
   * Fetch all user's drafts with pagination
   * @param limit Number of items per page (default 100)
   * @param offset Starting offset (default 0)
   */
  async getMyDrafts(limit = 100, offset = 0): Promise<z.infer<typeof GetDraftsResponseSchema>> {
    const url = `${this.mwApiUrl}/v1/design-service/my/drafts?limit=${limit}&offset=${offset}`;
    const res = await this.fetch(url);
    log.info('[MakerWorld API] getMyDrafts response:', JSON.stringify(res));
    const parsed = GetDraftsResponseSchema.safeParse(res);
    if (!parsed.success) {
      log.warn('Drafts list validation issues:', parsed.error.issues);
    }
    return (res || { hits: [], total: 0 }) as z.infer<typeof GetDraftsResponseSchema>;
  }

  /**
   * Fetch the upload page HTML and parse embedded design data
   * MakerWorld embeds design data in the page (Next.js __NEXT_DATA__ or similar)
   */
  private async fetchDesignsFromUploadPage(userHandle: string): Promise<{ hits: unknown[]; total: number } | null> {
    const url = `https://makerworld.com/en/@${userHandle}/upload`;
    log.info(`[MakerWorld API] Fetching upload page: ${url}`);

    if (!window.electron?.makerworld?.fetch) {
      throw new Error('MakerWorld IPC not available');
    }

    const response = await window.electron.makerworld.fetch(url, {
      method: 'GET',
      headers: {
        'Accept': 'text/html',
      },
    });

    if (!response.ok) {
      log.error(`[MakerWorld API] Failed to fetch upload page: ${response.status}`);
      return null;
    }

    const html = response.body;
    log.info(`[MakerWorld API] Got HTML page, length: ${html.length}`);

    // Try to find __NEXT_DATA__ script tag (common in Next.js apps)
    const nextDataMatch = html.match(/<script id="__NEXT_DATA__"[^>]*>([\s\S]*?)<\/script>/);
    if (nextDataMatch) {
      try {
        const nextData = JSON.parse(nextDataMatch[1]);
        log.info('[MakerWorld API] Found __NEXT_DATA__');

        // Navigate the Next.js data structure to find designs
        const pageProps = nextData?.props?.pageProps;
        if (pageProps) {
          // Log the pageProps keys to help debug
          log.info('[MakerWorld API] pageProps keys:', Object.keys(pageProps).join(', '));

          // Look for designs in various possible locations
          let designs = pageProps.designs || pageProps.models || pageProps.data?.designs ||
                       pageProps.data?.models || pageProps.initialData?.designs ||
                       pageProps.userDesigns || pageProps.publishedDesigns ||
                       pageProps.list || pageProps.items;

          // Also try nested structures
          if (!designs && pageProps.data) {
            log.info('[MakerWorld API] pageProps.data keys:', Object.keys(pageProps.data).join(', '));
            designs = pageProps.data.list || pageProps.data.items || pageProps.data.hits;
          }

          if (Array.isArray(designs)) {
            log.info(`[MakerWorld API] Found ${designs.length} designs in __NEXT_DATA__`);
            // Log the first design structure to understand the data format
            if (designs.length > 0) {
              log.info('[MakerWorld API] First design structure:', JSON.stringify(designs[0]));
            }
            return { hits: designs, total: designs.length };
          }

          // If still not found, log the full pageProps structure (truncated)
          const propsStr = JSON.stringify(pageProps);
          log.info('[MakerWorld API] pageProps (first 2000 chars):', propsStr.substring(0, 2000));
        }
      } catch (e) {
        log.error('[MakerWorld API] Failed to parse __NEXT_DATA__:', e);
      }
    }

    // Try to find design IDs from model links in the HTML
    const modelLinks = html.matchAll(/href="\/en\/models\/(\d+)[^"]*"/g);
    const designIds: number[] = [];
    for (const match of modelLinks) {
      const id = parseInt(match[1], 10);
      if (!designIds.includes(id)) {
        designIds.push(id);
      }
    }

    if (designIds.length > 0) {
      log.info(`[MakerWorld API] Found ${designIds.length} design IDs from HTML links: ${designIds.join(', ')}`);
      // Return minimal design objects with just IDs - we'll fetch full details later
      const hits = designIds.map(id => ({
        id,
        designId: id,
        title: `Design ${id}`, // Placeholder - will be fetched later
        status: 3,
      }));
      return { hits, total: designIds.length };
    }

    log.error('[MakerWorld API] Could not find designs in upload page');
    return null;
  }

  /**
   * Fetch all user's published designs
   * @param userHandle The user's MakerWorld handle (from auth context)
   * @param userId The user's MakerWorld UID (from auth context)
   */
  async getMyPublishedDesigns(userHandle: string, userId?: number): Promise<z.infer<typeof DraftSummarySchema>[]> {
    log.info(`[MakerWorld API] Fetching published designs for handle: ${userHandle}, uid: ${userId}`);

    // Try to fetch designs from the upload page HTML
    const response = await this.fetchDesignsFromUploadPage(userHandle);

    if (!response || response.hits.length === 0) {
      log.error('[MakerWorld API] Could not find designs from upload page');
      throw new MakerWorldClientAPIError({
        message: 'Could not fetch published designs from MakerWorld',
      });
    }

    log.info(`[MakerWorld API] Found ${response.hits.length} designs`);

    const allDesigns: z.infer<typeof DraftSummarySchema>[] = [];

    // For each design found, fetch full details if we only have ID
    for (const model of response.hits) {
      const m = model as Record<string, unknown>;
      const designId = (m.designId as number) || (m.id as number) || 0;

      // If we only have minimal data (from HTML parsing), try to get full details
      if (!m.title || m.title === `Design ${designId}`) {
        try {
          // Try to get draft details using the design ID
          // The draft ID might be different from the published design ID
          log.info(`[MakerWorld API] Fetching details for design ${designId}`);

          // Try fetching the model page to get details
          const modelUrl = `https://makerworld.com/en/models/${designId}`;
          const modelResponse = await window.electron!.makerworld!.fetch(modelUrl, {
            method: 'GET',
            headers: { 'Accept': 'text/html' },
          });

          if (modelResponse.ok) {
            const modelHtml = modelResponse.body;
            // Parse title from the page
            const titleMatch = modelHtml.match(/<title>([^<]*)<\/title>/);
            const title = titleMatch ? titleMatch[1].replace(' - MakerWorld', '').trim() : `Design ${designId}`;

            // Try to find cover image
            const coverMatch = modelHtml.match(/og:image"[^>]*content="([^"]*)"/);
            const cover = coverMatch ? coverMatch[1] : '';

            // Try to find description/summary
            const descMatch = modelHtml.match(/og:description"[^>]*content="([^"]*)"/);
            const summary = descMatch ? descMatch[1] : '';

            allDesigns.push({
              id: designId,
              designId: designId,
              title,
              summary,
              categoryId: 0,
              tags: [],
              cover,
              updateTime: '',
              createTime: '',
              status: 3,
            });

            log.info(`[MakerWorld API] Got details for design ${designId}: "${title}"`);
          } else {
            // Fallback to minimal data
            allDesigns.push({
              id: designId,
              designId: designId,
              title: `Design ${designId}`,
              summary: '',
              categoryId: 0,
              tags: [],
              cover: '',
              updateTime: '',
              createTime: '',
              status: 3,
            });
          }
        } catch (e) {
          log.warn(`[MakerWorld API] Failed to get details for design ${designId}:`, e);
          allDesigns.push({
            id: designId,
            designId: designId,
            title: `Design ${designId}`,
            summary: '',
            categoryId: 0,
            tags: [],
            cover: '',
            updateTime: '',
            createTime: '',
            status: 3,
          });
        }
      } else {
        // We have full data already - handle various field name conventions from __NEXT_DATA__
        // MakerWorld uses different field names in different contexts:
        // - designId/id for the design identifier
        // - title/name for the design name
        // - summary/description for the short description
        // - cover/coverUrl/thumbnail for the cover image
        const extractedId = (m.designId as number) || (m.id as number) || (m.modelId as number) || 0;
        const extractedTitle = (m.title as string) || (m.name as string) || '';
        const extractedSummary = (m.summary as string) || (m.description as string) || '';
        const extractedCover = (m.cover as string) || (m.coverUrl as string) || (m.thumbnail as string) || '';
        const extractedLicense = (m.license as string) || '';

        log.info(`[MakerWorld API] Extracted design: id=${extractedId}, title="${extractedTitle}", license="${extractedLicense}"`);

        allDesigns.push({
          id: extractedId,
          designId: extractedId,
          title: extractedTitle,
          summary: extractedSummary,
          categoryId: (m.categoryId as number) || (m.category as number) || 0,
          tags: (m.tags as string[]) || [],
          cover: extractedCover,
          updateTime: (m.updateTime as string) || (m.publishTime as string) || (m.updatedAt as string) || '',
          createTime: (m.createTime as string) || (m.publishTime as string) || (m.createdAt as string) || '',
          status: 3,
          license: extractedLicense,
        });
      }
    }

    log.info(`[MakerWorld API] Returning ${allDesigns.length} published designs`);
    return allDesigns;
  }

  /**
   * Fetch full design details from public API
   * @param designId The published design ID
   */
  async getDesignDetails(designId: number): Promise<z.infer<typeof DesignDetailSchema>> {
    const url = `${this.mwApiUrl}/v1/design-service/design/${designId}`;
    log.info(`[MakerWorld API] Fetching design details: ${url}`);
    const res = await this.fetch(url);
    return res as z.infer<typeof DesignDetailSchema>;
  }

  /**
   * Get model download URL for a design
   * @param designId The published design ID
   * @param modelType Type of model files to download (default: 'all')
   */
  async getModelDownloadUrl(designId: number, modelType = 'all'): Promise<z.infer<typeof ModelDownloadSchema>> {
    const url = `${this.mwApiUrl}/v1/design-service/design/${designId}/model?modelType=${modelType}&type=download`;
    log.info(`[MakerWorld API] Fetching model download URL: ${url}`);
    const res = await this.fetch(url);
    return res as z.infer<typeof ModelDownloadSchema>;
  }

  /**
   * Get instance (print profile) 3MF download URL
   * @param instanceId The instance/profile ID
   */
  async getInstanceDownloadUrl(instanceId: number): Promise<z.infer<typeof Instance3MFDownloadSchema>> {
    const url = `${this.mwApiUrl}/v1/design-service/instance/${instanceId}/f3mf?type=download&fileType=`;
    log.info(`[MakerWorld API] Fetching instance 3MF download URL: ${url}`);
    const res = await this.fetch(url);
    return res as z.infer<typeof Instance3MFDownloadSchema>;
  }

}
