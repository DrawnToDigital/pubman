/**
 * Client-side MakerWorld API that uses Electron IPC to bypass Cloudflare
 * This routes all requests through Electron's authenticated session
 */

import { z } from 'zod';
import log from 'electron-log/renderer';

// Window.electron types are defined in MakerWorldAuthContext.tsx

// Schemas
export const UserInfoResponseSchema = z.object({
  uid: z.number(),
  name: z.string(),
  handle: z.string(),
  avatar: z.string(),
  backgroundUrl: z.string(),
}).passthrough();

// Schema for draft summary (list response)
export const DraftSummarySchema = z.object({
  id: z.number(),
  designId: z.number(),
  title: z.string(),
  summary: z.string(),
  categoryId: z.number(),
  tags: z.array(z.string()),
  cover: z.string(),
  updateTime: z.string(),
  createTime: z.string(),
  status: z.number(),
}).passthrough();

export const GetDraftsResponseSchema = z.object({
  hits: z.array(DraftSummarySchema),
  total: z.number(),
});

// Schema for model file in draft details
export const ModelFileSchema = z.object({
  isAutoGenerated: z.boolean(),
  isDir: z.boolean(),
  modelName: z.string(),
  modelSize: z.number(),
  modelType: z.string(),
  modelUpdateTime: z.string().default(''),
  modelUrl: z.string(),
  thumbnailName: z.string().default(''),
  thumbnailSize: z.number().default(0),
  thumbnailUrl: z.string().default(''),
  unikey: z.string(),
}).passthrough();

// Schema for design picture
export const DesignPictureSchema = z.object({
  name: z.string(),
  url: z.string(),
}).passthrough();

export const DraftDetailResponseSchema = z.object({
  id: z.number(),
  designId: z.number(),
  title: z.string(),
  summary: z.string(),
  categoryId: z.number(),
  tags: z.array(z.string()),
  cover: z.string(),
  updateTime: z.string(),
  createTime: z.string(),
  status: z.number(),
  license: z.string(),
  nsfw: z.boolean(),
  modelFiles: z.array(ModelFileSchema).optional(),
  designPictures: z.array(DesignPictureSchema).optional(),
}).passthrough();

export class MakerWorldClientAPIError extends Error {
  url?: string;
  method?: string;
  requestBody?: string;
  responseStatus?: number;
  responseStatusText?: string;
  responseBody?: string;

  constructor(params: {
    message: string;
    url?: string;
    method?: string;
    requestBody?: string;
    responseStatus?: number;
    responseStatusText?: string;
    responseBody?: string;
  }) {
    super(params.message);
    this.name = 'MakerWorldClientAPIError';
    Object.assign(this, params);
  }
}

// MakerWorld draft status codes
export const MAKERWORLD_STATUS = {
  0: 'new',
  1: 'draft',
  3: 'published',
  6: 'submitted',
  10: 'pending_review',
} as const;

export function getMakerWorldStatusName(status: number): string {
  return MAKERWORLD_STATUS[status as keyof typeof MAKERWORLD_STATUS] || `unknown(${status})`;
}

export class MakerWorldClientAPI {
  private bblApiUrl = 'https://api.bambulab.com';
  private mwApiUrl = 'https://makerworld.com/api';
  private s3ConfigCache: {
    config: {
      region: string;
      endpoint: string;
      accessKeyId: string;
      accessKeySecret: string;
      securityToken: string;
      bucketName: string;
      cdnUrl: string;
    } | null;
    expiresAt: number;
  } = { config: null, expiresAt: 0 };

  // Note: Authentication is handled by session cookies in Electron's persist:makerworld partition
  // No access token is needed as session.fetch() automatically includes the auth cookies
  constructor() {}

  private validateId(id: string | number, paramName: string): void {
    if (id === '' || id === null || id === undefined) {
      throw new Error(`Invalid ${paramName}: value is empty or undefined`);
    }
    if (typeof id === 'number' && (isNaN(id) || id <= 0)) {
      throw new Error(`Invalid ${paramName}: ${id} is not a positive number`);
    }
  }

  private async fetch(url: string, options: { method?: string; body?: string } = {}): Promise<unknown> {
    if (!window.electron?.makerworld?.fetch) {
      throw new Error('MakerWorld IPC not available - are you running in Electron?');
    }

    const method = options.method || 'GET';

    // session.fetch() automatically includes cookies from the persist:makerworld partition
    // The 'token' cookie handles authentication for all MakerWorld/BambuLab API requests
    // No Authorization header needed - session cookies are used instead
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
    };

    // Log request details (full body for debugging)
    log.info(`[MakerWorld API] >>> ${method} ${url}`);
    if (options.body) {
      log.info(`[MakerWorld API] >>> Request body:`, options.body);
    }

    const startTime = Date.now();
    const response = await window.electron.makerworld.fetch(url, {
      method,
      headers,
      body: options.body,
    });
    const elapsed = Date.now() - startTime;

    // Log response details (full body for debugging)
    log.info(`[MakerWorld API] <<< ${response.status} ${response.statusText} (${elapsed}ms)`);
    if (response.body) {
      log.info(`[MakerWorld API] <<< Response body:`, response.body);
    } else {
      log.info(`[MakerWorld API] <<< Response body: (empty)`);
    }

    if (!response.ok) {
      const error = new MakerWorldClientAPIError({
        message: `MakerWorld API error: ${response.status} ${response.statusText}`,
        url,
        method,
        requestBody: options.body,
        responseStatus: response.status,
        responseStatusText: response.statusText,
        responseBody: response.body,
      });
      log.error(`[MakerWorld API] Request failed:`, {
        url,
        method,
        status: response.status,
        statusText: response.statusText,
      });
      throw error;
    }

    try {
      return response.body ? JSON.parse(response.body) : null;
    } catch (parseError) {
      log.error(`[MakerWorld API] Failed to parse response as JSON:`, parseError);
      throw new MakerWorldClientAPIError({
        message: 'Failed to parse response',
        url,
        method,
        responseStatus: response.status,
        responseBody: response.body,
      });
    }
  }

  async getUserInfo() {
    const url = `${this.bblApiUrl}/v1/design-user-service/my/preference`;
    const res = await this.fetch(url);
    const parsed = UserInfoResponseSchema.safeParse(res);
    if (!parsed.success) {
      throw new MakerWorldClientAPIError({
        message: 'Invalid user info response',
        url,
        responseBody: JSON.stringify(res),
      });
    }
    return parsed.data;
  }

  async getS3Config() {
    // Check cache first (with 5 minute buffer before expiration)
    const now = Date.now();
    if (this.s3ConfigCache.config && this.s3ConfigCache.expiresAt > now + 5 * 60 * 1000) {
      log.info(`[MakerWorld API] Using cached S3 config (expires in ${Math.round((this.s3ConfigCache.expiresAt - now) / 1000)}s)`);
      return this.s3ConfigCache.config;
    }

    const url = `${this.mwApiUrl}/v1/user-service/my/s3config?useType=1`;
    const config = await this.fetch(url) as {
      region: string;
      endpoint: string;
      accessKeyId: string;
      accessKeySecret: string;
      securityToken: string;
      bucketName: string;
      cdnUrl: string;
      expiration?: string;
    };

    // Cache the config with expiration
    if (config && config.expiration) {
      this.s3ConfigCache = {
        config,
        expiresAt: new Date(config.expiration).getTime(),
      };
      log.info(`[MakerWorld API] Cached S3 config until ${config.expiration}`);
    }

    return config;
  }

  async createDraft(draftData: Record<string, unknown>) {
    const url = `${this.mwApiUrl}/v1/design-service/my/draft`;
    return await this.fetch(url, {
      method: 'POST',
      body: JSON.stringify(draftData),
    });
  }

  async updateDraft(draftId: string | number, draftData: Record<string, unknown>) {
    this.validateId(draftId, 'draftId');
    const url = `${this.mwApiUrl}/v1/design-service/my/draft/${draftId}`;
    await this.fetch(url, {
      method: 'PUT',
      body: JSON.stringify(draftData),
    });
    return null;
  }

  async getDraftById(draftId: string | number) {
    this.validateId(draftId, 'draftId');
    const url = `${this.mwApiUrl}/v1/design-service/my/draft/${draftId}`;
    const res = await this.fetch(url);
    const parsed = DraftDetailResponseSchema.safeParse(res);
    if (!parsed.success) {
      log.warn('Draft validation issues:', parsed.error.issues);
    }
    return res as z.infer<typeof DraftDetailResponseSchema>;
  }

  async publishDraft(draftId: string | number): Promise<{ designId?: number }> {
    this.validateId(draftId, 'draftId');
    const url = `${this.mwApiUrl}/v1/design-service/my/draft/${draftId}/submit`;
    const res = await this.fetch(url, { method: 'POST' });
    return (res || {}) as { designId?: number };
  }

  async uploadFileToS3(
    fileName: string,
    fileData: ArrayBuffer,
    userId: number,
    s3Config: {
      region: string;
      endpoint: string;
      accessKeyId: string;
      accessKeySecret: string;
      securityToken: string;
      bucketName: string;
      cdnUrl: string;
    }
  ): Promise<{ url: string }> {
    // Generate the S3 key (matching the original format)
    const today = new Date().toISOString().slice(0, 10);
    const randomHex = Array.from(crypto.getRandomValues(new Uint8Array(8)))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
    const fileExt = fileName.includes('.') ? fileName.split('.').pop() : 'bin';
    const key = `makerworld/user/${userId}/draft/${today}_${randomHex}.${fileExt}`;

    log.info(`[MakerWorld S3] >>> PUT s3://${s3Config.bucketName}/${key}`);
    log.info(`[MakerWorld S3] >>> File: ${fileName}, Size: ${fileData.byteLength} bytes`);

    const { S3Client, PutObjectCommand } = await import('@aws-sdk/client-s3');

    const client = new S3Client({
      region: s3Config.region,
      endpoint: `https://${s3Config.endpoint}`,
      credentials: {
        accessKeyId: s3Config.accessKeyId,
        secretAccessKey: s3Config.accessKeySecret,
        sessionToken: s3Config.securityToken,
      },
    });

    // Sanitize filename for Content-Disposition header to prevent header injection
    // Remove all control characters (0x00-0x1F, 0x7F) plus quotes and backslashes
    const sanitizedFileName = fileName.replace(/[\x00-\x1F\x7F"\\]/g, '_');

    const command = new PutObjectCommand({
      Bucket: s3Config.bucketName,
      Key: key,
      Body: new Uint8Array(fileData),
      ContentDisposition: `attachment; filename="${sanitizedFileName}"`,
      ContentType: 'application/octet-stream',
    });

    try {
      await client.send(command);
      const resultUrl = `${s3Config.cdnUrl}/${key}`;
      log.info(`[MakerWorld S3] <<< Upload successful: ${resultUrl}`);
      return { url: resultUrl };
    } catch (error) {
      log.error(`[MakerWorld S3] <<< Upload failed:`, error);
      throw error;
    }
  }

  async uploadFile(fileName: string, fileData: ArrayBuffer, userId: number): Promise<{ url: string }> {
    const s3Config = await this.getS3Config() as {
      region: string;
      endpoint: string;
      accessKeyId: string;
      accessKeySecret: string;
      securityToken: string;
      bucketName: string;
      cdnUrl: string;
    };

    if (!s3Config || !s3Config.bucketName) {
      throw new MakerWorldClientAPIError({
        message: 'Failed to get S3 configuration',
        url: `${this.mwApiUrl}/v1/user-service/my/s3config?useType=1`,
      });
    }

    return await this.uploadFileToS3(fileName, fileData, userId, s3Config);
  }

  /**
   * Fetch all user's drafts with pagination
   * @param limit Number of items per page (default 100)
   * @param offset Starting offset (default 0)
   */
  async getMyDrafts(limit = 100, offset = 0): Promise<z.infer<typeof GetDraftsResponseSchema>> {
    const url = `${this.mwApiUrl}/v1/design-service/my/drafts?limit=${limit}&offset=${offset}`;
    const res = await this.fetch(url);
    const parsed = GetDraftsResponseSchema.safeParse(res);
    if (!parsed.success) {
      log.warn('Drafts list validation issues:', parsed.error.issues);
    }
    return (res || { hits: [], total: 0 }) as z.infer<typeof GetDraftsResponseSchema>;
  }

  /**
   * Fetch all user's published designs (filters drafts for published status)
   * Published designs have status=3 or designId > 0
   */
  async getMyPublishedDesigns(): Promise<z.infer<typeof DraftSummarySchema>[]> {
    const allDesigns: z.infer<typeof DraftSummarySchema>[] = [];
    let offset = 0;
    const limit = 100;
    let hasMore = true;

    while (hasMore) {
      const response = await this.getMyDrafts(limit, offset);

      // Filter for published designs (status=3 or designId > 0)
      const published = response.hits.filter(d => d.status === 3 || d.designId > 0);
      allDesigns.push(...published);

      offset += limit;
      hasMore = offset < response.total;
    }

    return allDesigns;
  }

}
