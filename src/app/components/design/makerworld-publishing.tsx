'use client';

import { PlatformPublishing, PlatformPublishingProps } from "./platform-publishing";
import { isPubmanLicenseSupported, makerWorldImageFileTypes, licenseToMakerWorldMap, makerWorldCategories, UpdateDraftRequestSchema } from "@/src/app/api/makerworld/makerworld-lib";
import { useMakerWorldAuth, MakerWorldUser } from "@/src/app/contexts/MakerWorldAuthContext";
import { MakerWorldClientAPI } from "@/src/app/lib/makerworld-client";
import log from 'electron-log/renderer';

// Browser-compatible path join (simple version for assets)
function joinPath(...parts: string[]): string {
  return parts.join('/').replace(/\/+/g, '/');
}

// Helper to get Electron FS API
function getElectronFS() {
  if (!window.electron?.fs?.readFile) {
    throw new Error('Electron FS not available');
  }
  return window.electron.fs;
}

// Helper to get app data path
async function getAppDataPath(): Promise<string> {
  if (!window.electron?.getAppDataPath) {
    throw new Error('Electron getAppDataPath not available');
  }
  return window.electron.getAppDataPath();
}

// Upload asset to MakerWorld S3
async function uploadAsset(
  api: MakerWorldClientAPI,
  asset: { file_name: string; file_ext: string },
  userId: number,
  appDataPath: string
): Promise<{ url: string }> {
  const fs = getElectronFS();
  const filePath = joinPath(appDataPath, 'assets', asset.file_name);
  const fileBuffer = await fs.readFile(filePath);
  return api.uploadFile(asset.file_name, fileBuffer, userId);
}

// Publish design to MakerWorld
async function publishToMakerWorld(
  api: MakerWorldClientAPI,
  design: PlatformPublishingProps['design'],
  user: MakerWorldUser,
  options?: { existingDraftId?: string | number; existingDesignId?: string | number; isPublished?: boolean }
): Promise<{ draftId: number; designId: number }> {
  const appDataPath = await getAppDataPath();
  const { existingDraftId, existingDesignId, isPublished } = options || {};

  // Upload all assets to S3
  const uploadedAssets: { images: { name: string; url: string }[]; models: { name: string; url: string; size: number }[] } = {
    images: [],
    models: [],
  };

  for (const asset of design.assets) {
    const ext = asset.file_ext.toLowerCase();
    const { url } = await uploadAsset(api, asset, user.uid, appDataPath);

    if (makerWorldImageFileTypes.includes(ext)) {
      uploadedAssets.images.push({ name: asset.file_name, url });
    } else {
      // Assume it's a model file
      uploadedAssets.models.push({ name: asset.file_name, url, size: 0 });
    }
  }

  // Get the MakerWorld license key
  const mwLicense = licenseToMakerWorldMap[design.license_key as keyof typeof licenseToMakerWorldMap] || 'Standard Digital File License';

  // Get category ID
  const categoryInfo = makerWorldCategories[design.makerworld_category as keyof typeof makerWorldCategories];
  const categoryId = categoryInfo?.id || null;

  // Build draft data using the schema to ensure all defaults are applied
  // - For new drafts: id=0, designId=0, parentId=0
  // - For updating existing draft: id=draftId, designId=0, parentId=0
  // - For updating published design: id=0, designId=existingDesignId, parentId=existingDesignId
  const existingDesignIdNum = isPublished && existingDesignId ? Number(existingDesignId) : 0;
  const draftData = UpdateDraftRequestSchema.parse({
    id: (!isPublished && existingDraftId) ? Number(existingDraftId) : 0,
    designId: existingDesignIdNum,
    parentId: existingDesignIdNum,
    title: design.main_name,
    summary: design.description || '',
    categoryId,
    tags: design.tags ? design.tags.map(t => t.tag) : [],
    license: mwLicense,
    nsfw: false,
    modelSource: 'original',
    cover: uploadedAssets.images[0]?.url || '',
    designPictures: uploadedAssets.images.map(img => ({ name: img.name, url: img.url })),
    modelFiles: uploadedAssets.models.map(model => ({
      modelName: model.name,
      modelUrl: model.url,
      modelSize: model.size,
      modelType: model.name.split('.').pop() || '',
      isAutoGenerated: false,
      unikey: '',
      thumbnailName: '',
      thumbnailSize: 0,
      thumbnailUrl: '',
      modelUpdateTime: '',
    })),
  });

  let result: { id: number; designId: number };

  if (isPublished) {
    // For published designs: create a new draft linked to the existing published design
    // This new draft will replace the published version when published
    const createResult = await api.createDraft(draftData) as { id: number; designId: number };
    result = createResult;
  } else if (existingDraftId) {
    // Update existing draft
    await api.updateDraft(existingDraftId, draftData);
    const draft = await api.getDraftById(existingDraftId);
    result = { id: draft.id, designId: draft.designId };
  } else {
    // Create new draft
    const createResult = await api.createDraft(draftData) as { id: number; designId: number };
    result = createResult;
  }

  return { draftId: result.id, designId: result.designId };
}

// Record the MakerWorld status in the local database
async function recordMakerWorldStatus(designId: string, platformDesignId: string | number, status: string) {
  const response = await fetch('/api/makerworld/model/record', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ designId, platformDesignId, status }),
  });

  if (!response.ok) {
    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
    log.error('Failed to record MakerWorld status:', errorData);
    throw new Error(errorData.error || 'Failed to record MakerWorld status');
  }
}

export function MakerWorldPublishing(props: PlatformPublishingProps) {
  const { isAuthenticated, accessToken, user } = useMakerWorldAuth();

  return (
    <PlatformPublishing
      {...props}
      platformName="MakerWorld"
      platformKey="MAKERWORLD"
      isAuthenticated={isAuthenticated}
      accessToken={accessToken}
      getPlatformStatus={(design) => {
        const mwPlatform = design.platforms.find(p => p.platform === "MAKERWORLD");
        if (!mwPlatform) return { status: 'not_published' };
        return {
          status: mwPlatform.published_status === 2 ? 'published' :
                  mwPlatform.published_status === 1 ? 'draft' :
                  'not_published',
          id: mwPlatform.platform_design_id,
          url: mwPlatform.published_status === 2
            ? `https://makerworld.com/en/models/${mwPlatform.platform_design_id}` :
            mwPlatform.published_status === 1
            ? `https://makerworld.com/en/my/models/drafts/${mwPlatform.platform_design_id}/edit` :
            undefined,
        };
      }}
      isValidForPlatform={(design, setErrorMessage) => {
        if (!design.main_name || design.main_name.trim() === "") {
          setErrorMessage("The design must have a name before publishing to MakerWorld.");
          return false;
        }
        if (!design.assets || design.assets.length === 0) {
          setErrorMessage("You need to add at least one file before publishing to MakerWorld");
          return false;
        }
        const hasImages = design.assets.some(asset =>
          makerWorldImageFileTypes.includes(asset.file_ext.toLowerCase())
        );
        if (!hasImages) {
          setErrorMessage("You need to add at least one image before publishing to MakerWorld");
          return false;
        }
        if (!isPubmanLicenseSupported(design.license_key)) {
          setErrorMessage("The selected license is not supported for MakerWorld.");
          return false;
        }
        if (!design.makerworld_category) {
          setErrorMessage("A MakerWorld category must be selected.");
          return false;
        }
        return true;
      }}
      publishDraft={async ({ design, designID, accessToken }) => {
        if (!user) throw new Error('Not authenticated to MakerWorld');

        const api = new MakerWorldClientAPI(accessToken);
        const { draftId } = await publishToMakerWorld(api, design, user);

        // Record in local database
        await recordMakerWorldStatus(designID, draftId, 'draft');

        return {
          id: String(draftId),
          url: `https://makerworld.com/en/my/models/drafts/${draftId}/edit`,
        };
      }}
      updateModel={async ({ design, designID, accessToken, platformId, platformStatus }) => {
        if (!user) throw new Error('Not authenticated to MakerWorld');

        const api = new MakerWorldClientAPI(accessToken);
        const isPublished = platformStatus === 'published';

        if (isPublished) {
          // For published designs: create new draft, publish it, update stays published
          const { draftId } = await publishToMakerWorld(api, design, user, {
            existingDesignId: platformId,
            isPublished: true,
          });

          // Publish the new draft to update the published design
          await api.publishDraft(draftId);

          // Record in local database (keep same platformId since it's the published designId)
          await recordMakerWorldStatus(designID, platformId, 'published');

          return {
            status: 'published',
            id: platformId,
            url: `https://makerworld.com/en/models/${platformId}`,
          };
        } else {
          // For drafts: update the existing draft
          await publishToMakerWorld(api, design, user, { existingDraftId: platformId });

          // Record in local database
          await recordMakerWorldStatus(designID, platformId, 'draft');

          return {
            status: 'draft',
            id: platformId,
            url: `https://makerworld.com/en/my/models/drafts/${platformId}/edit`,
          };
        }
      }}
      publishPublic={async ({ design, designID, accessToken, platformId }) => {
        if (!user) throw new Error('Not authenticated to MakerWorld');
        if (!design) throw new Error('Design data is required');

        const api = new MakerWorldClientAPI(accessToken);

        // First update the draft with latest data
        await publishToMakerWorld(api, design, user, { existingDraftId: platformId });

        // Then submit for public publishing
        await api.publishDraft(platformId);

        // Get the published design ID (it changes after publish)
        const draft = await api.getDraftById(platformId);
        const publishedDesignId = draft.designId;

        // Record in local database
        await recordMakerWorldStatus(designID, publishedDesignId, 'published');

        log.info(`MakerWorld model published: ${publishedDesignId}`);

        return {
          id: String(publishedDesignId),
          url: `https://makerworld.com/en/models/${publishedDesignId}`,
        };
      }}
    />
  );
}
