import { NextResponse } from "next/server";
import {
  MakerWorldAPI,
  UpdateDraftRequestSchema,
  makerWorldCategories,
  licenseToMakerWorldMap,
  MakerWorldAPIError,
  makerWorldImageFileTypes
} from "../makerworld-lib";
import log from "electron-log/renderer";
import { getDatabase } from "../../../lib/betterSqlite3";
import {designSchema} from "../../../components/design/types";
import path from "path";
import fs from "fs";

const MAKERWORLD_PLATFORM_ID = 5;
const PUBLISHED_STATUS_DRAFT = 1;
const PUBLISHED_STATUS_PUBLISHED = 2;

function mapDesignDataToMakerWorldDraft(designData, images, modelFiles, makerWorldDesignId, makerWorldDraftId) {
  const d = designSchema.parse(designData);
  return UpdateDraftRequestSchema.parse({
    "designId": makerWorldDesignId ? parseInt(makerWorldDesignId) : 0,
    "parentId": makerWorldDesignId ? parseInt(makerWorldDesignId) : 0,
    "id": makerWorldDraftId ? parseInt(makerWorldDraftId) : 0,
    "title": d.main_name,
    "summary": d.description,
    "categoryId": makerWorldCategories[d.makerworld_category]?.id || null,
    "license": licenseToMakerWorldMap[d.license_key],
    "exclusive": 0,
    "nsfw": false,
    "modelSource": "original",
    "tags": d.tags ? d.tags.map(tag => tag.tag) : [],
    "cover": images.find(img => img.url)?.url || '',
    "designPictures": images.map(img => ({
      "name": img.name,
      "url": img.url
    })),
    "modelFiles": modelFiles.map(file => ({
      "isAutoGenerated": false,
      "isDir": false,
      "modelName": file.name,
      "modelSize": file.size || 0,
      "modelType": file.extension || 'stl',
      "modelUpdateTime": "",
      "modelUrl": file.url,
      "thumbnailName": "",
      "thumbnailSize": 0,
      "thumbnailUrl": "",
      "unikey": ""
    })),
    "designSetting": {
      "submitAsPrivate": false
    },
    "draftSetting": {
      "createStep": "",
      "createWith3mf": false
    },
    "paidSetting": {
      "isPaid": false
    },
  });
}

export async function POST(request) {
  try {
    const accessToken = request.headers.get('x-makerworld-token');
    if (!accessToken) {
      return NextResponse.json({ error: 'Missing MakerWorld access token' }, { status: 401 });
    }
    const { designId, designData, makerWorldId, makerWorldStatus } = await request.json();
    if (!accessToken || !designId || !designData) {
      return NextResponse.json({ error: 'Missing required parameters' }, { status: 400 });
    }

    const api = new MakerWorldAPI(accessToken);
    const db = getDatabase();

    const makerWorldUser = await api.getUserInfo();
    const makerWorldUserId = makerWorldUser?.uid;
    if (!makerWorldUserId) {
      log.error('Failed to retrieve MakerWorld user ID', makerWorldUser);
      return NextResponse.json({ error: 'Failed to retrieve MakerWorld user ID' }, { status: 500 });
    }
    log.info(`MakerWorld user ID: ${makerWorldUserId}`);

    const images = [];
    const modelFiles = [];

    // File processing logic
    if (designData.assets && designData.assets.length > 0) {
      // Upload new assets
      for (const asset of designData.assets) {
        try {
          // Extract file path from URL
          let filePath = asset.url.replace('local://', '');
          // Handle paths appropriately based on context
          if (filePath.startsWith('/assets/')) {
            const appDataPath = process.env.NEXT_PUBLIC_APP_DATA_PATH || path.join(process.cwd(), 'appdata');
            filePath = path.join(appDataPath, filePath);
          }
          const fileBuffer = fs.readFileSync(filePath);
          const uploadResult = await api.uploadFile(asset.file_name, fileBuffer, makerWorldUserId);
          log.info(`Uploaded file: ${asset.file_name}`, uploadResult);
          if (makerWorldImageFileTypes.includes(asset.file_ext.toLowerCase())) {
            images.push({
              name: asset.file_name,
              url: uploadResult.url,
              extension: asset.file_ext.toLowerCase(),
              size: fileBuffer.byteLength,
            });
          } else {
            modelFiles.push({
              name: asset.file_name,
              url: uploadResult.url,
              extension: asset.file_ext.toLowerCase(),
              size: fileBuffer.byteLength,
            });
          }
        } catch (error) {
          log.error(`Failed to upload file ${asset.file_name}:`, error);
          return NextResponse.json({ error: 'Some files failed to upload', details: error }, { status: 500 });
        }
      }
    }

    let draftResponse;
    let newMakerWorldId = makerWorldId || null;

    if (!newMakerWorldId) {
      // Create new draft
      const draftData = mapDesignDataToMakerWorldDraft(designData, images, modelFiles, null, null);
      draftResponse = await api.createDraft(draftData);
      if (!draftResponse || !draftResponse.id) {
        log.error('Failed to create MakerWorld draft:', draftResponse);
        return NextResponse.json({ error: 'Failed to create MakerWorld draft' }, { status: 500 });
      }
      newMakerWorldId = draftResponse.id;

      // Record the creation in design_platform table
      db.prepare(`
        INSERT INTO design_platform (platform_id, design_id, platform_design_id, published_status, created_at, updated_at)
        VALUES (?, ?, ?, ?, datetime('now'), datetime('now'))
      `).run(MAKERWORLD_PLATFORM_ID, designId, newMakerWorldId.toString(), PUBLISHED_STATUS_DRAFT);
    } else if (makerWorldStatus !== 'published') {
      // Update existing draft
      const draftData = mapDesignDataToMakerWorldDraft(designData, images, modelFiles, null, newMakerWorldId);
      await api.updateDraft(newMakerWorldId, draftData);
      db.prepare(`
        UPDATE design_platform
        SET published_status = ?, updated_at = datetime('now')
        WHERE platform_id = ? AND design_id = ?
      `).run(PUBLISHED_STATUS_DRAFT, MAKERWORLD_PLATFORM_ID, designId);

      if (designData.draft === false) {
        // Publish the draft
        const draftId = newMakerWorldId;
        await api.publishDraft(draftId);
        // Attempt over 30 seconds to get designId from getDraft(draftId)
        const maxAttempts = 30;
        let attempts = 0;
        let newDesignId = null;
        let lastError = null;
        while (attempts < maxAttempts) {
          try {
            const draftDetails = await api.getDraftById(draftId);
            if (draftDetails && draftDetails.designId) {
              newDesignId = draftDetails.designId;
              log.info(`Published design ID: ${newDesignId}`);
              break;
            }
          } catch (error) {
            if (error instanceof MakerWorldAPIError) {
              log.error(error.validationIssues);
            }
            lastError = error;
          }
          attempts++;
          await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second before retrying
        }
        if (!newDesignId) {
          log.error(`Failed to retrieve published design ID from MakerWorld after ${maxAttempts} attempts:`, lastError);
          return NextResponse.json({ error: `Failed to retrieve published design ID from MakerWorld: ${lastError}` }, { status: 500 });
        }
        newMakerWorldId = newDesignId.toString();

        db.prepare(`
          UPDATE design_platform
          SET published_status = ?, platform_design_id = ?, updated_at = datetime('now'), published_at = NULL
          WHERE platform_id = ? AND design_id = ?
        `).run(PUBLISHED_STATUS_PUBLISHED, newMakerWorldId, MAKERWORLD_PLATFORM_ID, designId);
      }
    } else {
      // makerWorldStatus === 'published'
      // Create a new draft from our existing design, then publish the draft
      const draftData = mapDesignDataToMakerWorldDraft(designData, images, modelFiles, newMakerWorldId, null);
      const tempDraftResp = await api.createDraft(draftData);
      if (!tempDraftResp || !tempDraftResp.id) {
        return NextResponse.json({ error: 'Failed to update MakerWorld model - temp draft' }, { status: 500 });
      }
      const tempDraftId = tempDraftResp.id;
      // Publish the draft
      await api.publishDraft(tempDraftId);
      db.prepare(`
        UPDATE design_platform
        SET published_status = ?, updated_at = datetime('now'), published_at = datetime('now')
        WHERE platform_id = ? AND design_id = ?
      `).run(PUBLISHED_STATUS_PUBLISHED, MAKERWORLD_PLATFORM_ID, designId);
    }

    // Get the updated record from the database
    const designPlatform = db.prepare(`
      SELECT
        platform_design_id,
        published_status,
        strftime('%Y-%m-%dT%H:%M:%fZ', created_at) as created_at,
        strftime('%Y-%m-%dT%H:%M:%fZ', updated_at) as updated_at,
        strftime('%Y-%m-%dT%H:%M:%fZ', published_at) as published_at
      FROM design_platform
      WHERE platform_id = ? AND design_id = ?
    `).get(MAKERWORLD_PLATFORM_ID, designId);

    return NextResponse.json({
      message: makerWorldId ? `Design updated on MakerWorld` : `Design published to MakerWorld as draft`,
      makerWorldId: designPlatform.platform_design_id,
      makerWorldUrl: designPlatform.published_status === PUBLISHED_STATUS_PUBLISHED ?
        `https://makerworld.com/en/models/${newMakerWorldId}` :
        `https://makerworld.com/en/my/models/drafts/${newMakerWorldId}/edit`,
      designPlatform
    }, { status: makerWorldId ? 200 : 201 });
  } catch (error) {
    log.error('Failed to create MakerWorld model:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}
